# Glucose Levels Feature

## Overview

The Glucose Levels feature gives users two views of their glucose data:

1. **Dashboard widget** — displays the current (simulated) glucose level with a color-coded status indicator and a wellness message.
2. **Glucose Trends chart** — a time-series scatter plot of today's glucose readings pulled from the database, rendered with Recharts.

Historical data is loaded into the database via a CSV injection script, while the current glucose reading shown on the dashboard is generated by a simulator.

---

## Backend

### Database Model (`backend/models.py`)

The `GlucoseReading` table stores individual data points:

| Column          | Type           | Description                                        |
|-----------------|----------------|----------------------------------------------------|
| `id`            | Integer (PK)   | Auto-generated primary key                         |
| `user_id`       | Integer (FK)   | References `user.id` (optional, indexed)           |
| `timestamp_utc` | DateTime       | UTC timestamp of the reading (indexed)             |
| `glucose_mg_dl` | Integer        | Glucose value in mg/dL                             |
| `tag`           | String (opt.)  | Context tag, e.g. `"breakfast"`, `"lunch"`         |
| `source`        | String         | Data origin, defaults to `"simulated"`             |

### Glucose Simulator (`backend/simulator.py`)

`get_current_glucose_level()` generates a mock real-time reading:

- Base value of **110 mg/dL** with a random offset in the range **-30 to +40**.
- Returns a status label based on the result:
  - `"Low"` if < 80
  - `"Normal"` if 80–140
  - `"Elevated"` if > 140
- Output: `{ "level": <int>, "status": "<string>" }`

This is used by the dashboard and the AI craving analysis engine.

### API Endpoints (`backend/main.py`)

All endpoints require a valid JWT Bearer token.

#### `GET /status`

Returns the user's dashboard data, including the current simulated glucose level.

#### `GET /glucose/trends`

Returns historical glucose readings within a given time range.

### Data Injection Scripts (`backend/data injection/`)

| Script                | Purpose                                                          |
|-----------------------|------------------------------------------------------------------|
| `load_glucose_csv.py` | Reads `backend/glucose_trends_from_today_jerusalem_60d.csv`, deletes existing readings for the target user, and inserts all rows. Handles UTC timestamp parsing and normalization. |
| `reset_glucose.py`    | Deletes all rows from the `glucosereading` table.                |

---

## Frontend

### 1. Dashboard Glucose Widget (`frontend/src/App.jsx`)

Part of the main `Dashboard` component (not a separate file).

- On mount, calls `GET /status` and extracts the `glucose` object.
- Displays the glucose level as a large number with the unit "mg/dL".
- **Color coding:** if the level exceeds 140, the number is rendered with a red alert style; otherwise it uses the default style.
- Also displays the wellness message returned by the endpoint.

### 2. GlucoseChart Component (`frontend/src/components/HealthWidgets.jsx`)

A dedicated React component for the trends view.

#### State

| State        | Purpose                                          |
|--------------|--------------------------------------------------|
| `readings`   | Array of glucose readings from the API           |
| `loading`    | True while fetching data                         |
| `fetchError` | Error message string (if any)                    |
| `endTime`    | Current time, rounded down to the nearest 30 min |

---

## End-to-End Flow

### Current Glucose (Dashboard)

```
1. User opens the app (dashboard is the default view)
2. App.jsx mounts, calls GET /status with Bearer token
3. Backend authenticates, runs get_current_glucose_level()
4. Simulator returns a randomized glucose value + status
5. Backend adds wellness message, returns full response
6. Dashboard displays the glucose number (red if > 140) and message
```

### Glucose Trends (Chart View)

```
1. User taps "Glucose" icon in bottom nav
2. GlucoseChart component mounts
3. useEffect fires  ──►  GET /glucose/trends?start=08:00&end=now
4. Backend authenticates, queries glucosereading table for today's range
5. Returns array of { timestamp_utc, glucose_mg_dl, tag, source }
6. Frontend converts timestamps to ms, renders ScatterChart
7. User can hover over data points to see exact values
```

### Data Seeding

```
1. Run: python "backend/data injection/load_glucose_csv.py"
2. Script connects to SQLite, finds the target user
3. Deletes existing readings for that user
4. Parses CSV, inserts GlucoseReading rows
5. Data is now available via GET /glucose/trends
```

---

## Current Data: Fully Simulated

**All glucose data in the system is simulated.** No real glucose monitor or sensor is connected. The data comes from two distinct simulation mechanisms:

### 1. Dashboard — random simulator (`backend/simulator.py`)

The `get_current_glucose_level()` function generates a fresh random value on every call:

```python
base_glucose = 110
fluctuation = random.randint(-30, 40)
current_level = base_glucose + fluctuation
```

This means every time the user refreshes the dashboard (or `GET /status` is called), they see a different glucose number between ~80 and ~150 mg/dL. There is no persistence — the value is not stored in the database. It exists only for the duration of the HTTP response.

### 2. Trends chart — CSV-injected historical data

The scatter chart is populated by pre-generated data loaded into the `glucosereading` table:

1. A CSV file (`backend/glucose_trends_from_today_jerusalem_60d.csv`) contains ~60 days of fabricated glucose readings with UTC timestamps, values, and context tags (e.g., `"breakfast"`, `"lunch"`).
2. The injection script (`backend/data injection/load_glucose_csv.py`) connects to SQLite, looks up a specific user (`"hansis"`), deletes that user's existing readings, and bulk-inserts every CSV row as a `GlucoseReading` record.
3. The reset script (`backend/data injection/reset_glucose.py`) can wipe the table entirely.

The frontend's `GET /glucose/trends` endpoint then queries these pre-loaded rows, filtered by today's date range.

---

## Future: Real Data Integration

Replacing simulated data with real glucose readings requires two things: a data source (device or manual input) and a pipeline to get that data into the existing `GlucoseReading` table. The rest of the system — the API, chart, dashboard, and AI engine — would work without changes.

### 1. Manual user input (low effort)

The simplest path: add a form in the frontend (similar to the Food Log form) that lets users manually enter a glucose reading.

- **Frontend:** a new component with fields for glucose value (mg/dL), an optional tag (dropdown: fasting, before meal, after meal), and a timestamp (defaulting to now).
- **Backend:** a new `POST /glucose/readings` endpoint that validates the input and inserts a `GlucoseReading` with `source = "manual"`.
- **Dashboard change:** replace `get_current_glucose_level()` with a query for the most recent `GlucoseReading` from the database, falling back to the simulator if no recent reading exists.

```
User enters glucose value + tag
       │
       ▼
POST /glucose/readings  ──►  Insert GlucoseReading (source="manual")
       │
       ▼
GET /glucose/trends now returns real + manual data on the chart
GET /status returns the latest real reading instead of a random number
```

### 2. Continuous Glucose Monitor (CGM) via Bluetooth (medium effort)

Consumer CGMs like the **Dexcom G7** or **FreeStyle Libre 3** can transmit readings via Bluetooth to a phone. Integration would work as follows:

```
CGM sensor (on body)
       │  Bluetooth
       ▼
Mobile app / Web Bluetooth API
       │
       ▼
POST /glucose/readings  ──►  Insert GlucoseReading
  {                                (source="cgm_dexcom")
    glucose_mg_dl: 112,
    tag: "auto",
    timestamp_utc: "2026-02-14T10:30:00Z"
  }
```

- **Web Bluetooth option:** the browser's Web Bluetooth API can pair with a CGM transmitter directly. A frontend service would read characteristics from the BLE device and POST each reading to the backend. Best for real-time, no-app-install demos.
- **Companion app relay:** if the user already has the manufacturer's app (Dexcom Clarity, LibreLink), a backend integration could pull readings via the manufacturer's cloud API (Dexcom Share API, LibreLinkUp) on a scheduled interval.
- **Data format:** CGMs typically report a reading every 1–5 minutes. The existing `GlucoseReading` model already supports this granularity with its `timestamp_utc` and `glucose_mg_dl` columns. The `source` field would be set to `"cgm_dexcom"` or `"cgm_libre"` to distinguish from manual entries.

### 3. Third-party health platform sync (higher effort)

For broader device compatibility, integrate with aggregator platforms:

- **Apple HealthKit** (iOS) / **Google Health Connect** (Android) — these collect glucose data from any connected device. A mobile wrapper (e.g., React Native or Capacitor) could read HealthKit data and sync to the backend.
- **Nightscout** — an open-source CGM data platform popular in the diabetes community. It exposes a REST API that our backend could poll periodically.

A new backend service (cron job or background task) would:
1. Authenticate with the external platform via OAuth.
2. Fetch new readings since the last sync timestamp.
3. Insert them as `GlucoseReading` rows with the appropriate `source` value.

### What stays the same

The core architecture is **already designed for real data**:

The only required backend change is replacing the `get_current_glucose_level()` simulator call in `GET /status` with a database lookup for the user's most recent `GlucoseReading`. Everything else is a matter of adding a new data ingestion pathway — the consumption side of the system is already production-ready.
